<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clipboard Performance Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1800px; /* Increased from 1200px */
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 95vh;
        }
        .top-container {
            flex: 1;
            margin-bottom: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 45vh;
        }
        .bottom-container {
            flex: 1;
            display: flex;
            gap: 20px;
            min-height: 45vh;
        }
        .left-column, .right-column {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .controls {
            margin-bottom: 20px;
            overflow-y: auto;
            flex: 1;
        }
        #log-container {
            border: 1px solid #ccc;
            padding: 10px;
            height: 100%;
            overflow-y: auto;
            background-color: #f9f9f9;
            font-family: monospace;
            flex: 1;
        }
        button {
            margin: 5px;
            padding: 8px 16px;
        }
        .button-group {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background-color: #f5f5f5;
        }
        .group-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .format-options {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            background-color: #f9f9f9;
        }
        .format-option {
            margin: 5px 0;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #eee;
        }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .custom-format-count {
            width: 60px;
            margin-left: 10px;
        }
        /* Table Styles */
        .records-container {
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
            overflow-y: auto;
            flex: 1;
            max-height: 100%;
        }
        .records-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .records-table {
            width: 100%;
            border-collapse: collapse;
        }
        .records-table th,
        .records-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .records-table th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .records-table tr:nth-child(even) {
            background-color: #f5f5f5;
        }
        .records-table tr:hover {
            background-color: #e9e9e9;
        }
        .records-actions {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .records-table tr.highlighted {
            background-color: #ffffc0 !important; /* Light yellow highlight */
            font-weight: bold;
        }
        .seed-record {
            background-color: #e0f7fa !important; /* Light cyan background */
        }
        .seed-record td {
            color: #006064;
        }
        .highlight-checkbox {
            margin-right: 5px;
        }
        .format-size {
            width: 60px;
            margin-left: 10px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <h1>Clipboard Performance Test</h1>

    <div class="top-container">
        <div class="records-container">
            <div class="records-title">Clipboard Records</div>
            <div class="records-actions">
                <button id="clear-records">Clear Records</button>
                <button id="record-btn">Record</button>
                <button id="export-records">Export as CSV</button>
                <button id="upload-csv-btn">Upload CSV</button>
                <button id="import-records">Import CSV</button>
                <button id="rerun-all-btn">Rerun All</button>
                <button id="rerun-all-new-btn">Re-run all (new)</button>
                <button id="load-seed-btn">Load Seed</button>
                <button id="copy-for-seed-btn">Copy table for seed</button>
                <input type="file" id="csv-file-input" accept=".csv" style="display: none;">
            </div>
            <table class="records-table" id="records-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Time</th>
                        <th>Size (MB)</th>
                        <th>Duration (ms)</th>
                        <th>Throughput (MB/s)</th>
                        <th>NumFormats</th>
                        <th>Size/Type (MB)</th>
                        <th>Format Sizes</th>
                        <th>Formats</th>
                        <th>Machine</th>
                        <th>Highlight</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="records-body"></tbody>
                    <!-- Record rows will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <div class="bottom-container">
        <div class="left-column">
            <div class="controls">
                <div>
                    <label for="data-size">Default Data Size (MB): </label>
                    <input type="number" id="data-size" value="50" min="1" max="100">
                </div>
                
                <div class="format-options">
                    <div class="group-title">Machine Information:</div>
                    <div>
                        <label for="machine-details">Machine Details: </label>
                        <input type="text" id="machine-details" placeholder="OS, RAM, CPU" 
                               style="width: 80%;" value="">
                        <button id="detect-machine-btn" style="padding: 4px 8px; margin-left: 5px;">Auto-detect</button>
                    </div>
                </div>
                
                <div class="format-options">
                    <div class="group-title">Clipboard Format Options:</div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-text-plain" checked>
                        <label for="format-text-plain">text/plain</label>
                        <input type="number" id="format-text-plain-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-text-plain-size">MB</label>
                    </div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-text-html">
                        <label for="format-text-html">text/html</label>
                        <input type="number" id="format-text-html-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-text-html-size">MB</label>
                    </div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-custom">
                        <label for="format-custom">Custom formats</label>
                        <input type="number" id="custom-format-count" class="custom-format-count" value="1" min="1" max="10">
                        <label for="custom-format-count">count</label>
                        <input type="number" id="format-custom-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-custom-size">MB</label>
                    </div>
                </div>
                
                <div class="button-group">
                    <div class="group-title">Write Operations</div>
                    <button id="write-btn">Write to Clipboard</button>
                    <button id="run-experiment-btn">Run Experiment</button>
                </div>
                
                <div class="button-group">
                    <div class="group-title">Read Operations</div>
                    <button id="read-btn">Read from Clipboard</button>
                </div>

                <button id="clear-log">Clear Log</button>
            </div>
        </div>
        
        <div class="right-column">
            <div id="log-container"></div>
        </div>
    </div>

    <script>
    const seededClipboardRecords = [
    {
        "datetime": "2025-03-28T07:47:40.329Z",
        "totalSizeMB": 50,
        "copyTimeMs": 164.6,
        "types": [
            "text/plain"
        ],
        "formatSizes": {
            "text/plain": 50
        },
        "sizePerType": 50,
        "throughput": 303.77,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:47:46.296Z",
        "totalSizeMB": 50,
        "copyTimeMs": 158.4,
        "types": [
            "text/plain"
        ],
        "formatSizes": {
            "text/plain": 50
        },
        "sizePerType": 50,
        "throughput": 315.66,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:11.737Z",
        "totalSizeMB": 50,
        "copyTimeMs": 175.6,
        "types": [
            "text/plain"
        ],
        "formatSizes": {
            "text/plain": 50
        },
        "sizePerType": 50,
        "throughput": 284.74,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:12.795Z",
        "totalSizeMB": 50,
        "copyTimeMs": 155,
        "types": [
            "text/plain"
        ],
        "formatSizes": {
            "text/plain": 50
        },
        "sizePerType": 50,
        "throughput": 322.58,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:23.067Z",
        "totalSizeMB": 50,
        "copyTimeMs": 474.7,
        "types": [
            "text/html"
        ],
        "formatSizes": {
            "text/html": 50
        },
        "sizePerType": 50,
        "throughput": 105.33,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:29.100Z",
        "totalSizeMB": 50,
        "copyTimeMs": 475.4,
        "types": [
            "text/html"
        ],
        "formatSizes": {
            "text/html": 50
        },
        "sizePerType": 50,
        "throughput": 105.17,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:38.361Z",
        "totalSizeMB": 100,
        "copyTimeMs": 605,
        "types": [
            "text/plain",
            "text/html"
        ],
        "formatSizes": {
            "text/plain": 50,
            "text/html": 50
        },
        "sizePerType": 50,
        "throughput": 165.29,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:46.152Z",
        "totalSizeMB": 100,
        "copyTimeMs": 607.9,
        "types": [
            "text/plain",
            "text/html"
        ],
        "formatSizes": {
            "text/plain": 50,
            "text/html": 50
        },
        "sizePerType": 50,
        "throughput": 164.5,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    },
    {
        "datetime": "2025-03-28T07:48:50.673Z",
        "totalSizeMB": 100,
        "copyTimeMs": 587.8,
        "types": [
            "text/plain",
            "text/html"
        ],
        "formatSizes": {
            "text/plain": 50,
            "text/html": 50
        },
        "sizePerType": 50,
        "throughput": 170.13,
        "highlighted": false,
        "systemInfo": {
            "os": "MacOS",
            "ram": "8 GB",
            "cpu": "12 Cores",
            "formatted": "MacOS, 8 GB, 12 Cores",
            "userProvided": true
        }
    }
];
    </script>

    <script>
        // Global variables
        let generatedData = '';
        let lastWriteTime = 0;
        let previousWriteTime = 0;
        let lastReadTypes = [];
        let lastReadTime = 0;
        let lastReadMB = 0;
        let previousReadTime = 0;
        let lastGeneratedSize = 0; // Track the last generated data size
        let lastFormatSizes = {}; // Track last read format sizes
        let clipboardRecords = []; // New array to store records
        
        // Function to get system information
        function getSystemInfo() {
            // Get OS information
            const userAgent = navigator.userAgent;
            let os = "Unknown OS";
            if (userAgent.indexOf("Windows") !== -1) os = "Windows";
            else if (userAgent.indexOf("Mac") !== -1) os = "MacOS";
            else if (userAgent.indexOf("Linux") !== -1) os = "Linux";
            else if (userAgent.indexOf("Android") !== -1) os = "Android";
            else if (userAgent.indexOf("iOS") !== -1 || userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1) os = "iOS";
            
            // Get RAM information - this is limited in browsers
            let ram = "Unknown";
            if (navigator.deviceMemory) {
                ram = `${navigator.deviceMemory} GB`;
            }
            
            // Get CPU information - this is very limited in browsers
            let cpu = "Unknown";
            if (navigator.hardwareConcurrency) {
                cpu = `${navigator.hardwareConcurrency} Cores`;
            }
            
            const autoDetectedInfo = `${os}, ${ram}, ${cpu}`;
            
            // Populate the machine details field with auto-detected info if it's empty
            const machineDetailsInput = document.getElementById('machine-details');
            if (machineDetailsInput && !machineDetailsInput.value) {
                machineDetailsInput.value = autoDetectedInfo;
            }
            
            return {
                os,
                ram,
                cpu,
                formatted: autoDetectedInfo
            };
        }
        
        // System info for current machine
        const systemInfo = getSystemInfo();
        
        // Function to get current machine info (user-entered or auto-detected)
        function getCurrentMachineInfo() {
            const machineDetailsInput = document.getElementById('machine-details');
            if (machineDetailsInput && machineDetailsInput.value.trim()) {
                // Use user-provided info if available
                const userInfo = machineDetailsInput.value.trim();
                // Parse into components for better structured data
                const parts = userInfo.split(',').map(part => part.trim());
                return {
                    os: parts[0] || "Unknown OS",
                    ram: parts.length > 1 ? parts[1] : "Unknown",
                    cpu: parts.length > 2 ? parts[2] : "Unknown",
                    formatted: userInfo,
                    userProvided: true
                };
            } else {
                // Fall back to auto-detected info
                return systemInfo;
            }
        }
        
        // Function to generate data of specified size in MB
        function generateDataOfSize(sizeInMB) {
            const bytesPerMB = 1024 * 1024;
            const targetBytes = sizeInMB * bytesPerMB;
            
            log(`Generating ${sizeInMB} MB of data...`);
            
            // Creating data in chunks to avoid memory issues
            const chunkSize = 1024 * 1024; // 1MB chunks
            let result = '';
            
            // Each character in JavaScript is 2 bytes
            const totalChars = targetBytes / 2;
            const chunksNeeded = Math.ceil(totalChars / chunkSize);
            
            for (let i = 0; i < chunksNeeded; i++) {
                const remainingChars = Math.min(chunkSize, totalChars - result.length);
                result += 'A'.repeat(remainingChars);
                
                if (i % 5 === 0 || i === chunksNeeded - 1) {
                    // Update progress every 5 chunks or at the end
                    const progress = Math.round((result.length / totalChars) * 100);
                    log(`Generation progress: ${progress}%`, "info", true);
                }
            }
            
            log(`Data generated: ${(result.length * 2 / bytesPerMB).toFixed(2)} MB`, "success");
            return result;
        }

        // Function to get selected formats
        function getSelectedFormats() {
            const formats = [];
            if (document.getElementById('format-text-plain').checked) {
                formats.push('text/plain');
            }
            if (document.getElementById('format-text-html').checked) {
                formats.push('text/html');
            }
            
            const useCustomFormats = document.getElementById('format-custom').checked;
            if (useCustomFormats) {
                const count = parseInt(document.getElementById('custom-format-count').value) || 1;
                for (let i = 1; i <= count; i++) {
                    formats.push(`web custom/format-${i}`);
                }
            }
            
            return formats;
        }

        // Function to write data to clipboard in selected formats
        async function writeDataToClipboard(data) {
            const selectedFormats = getSelectedFormats();
            
            if (selectedFormats.length === 0) {
                log("Please select at least one format!", "error");
                return null;
            }
            
            log(`Writing ${(data.length * 2 / (1024 * 1024)).toFixed(2)} MB of data to clipboard in ${selectedFormats.length} formats...`);
            log(`Formats: ${selectedFormats.join(', ')}`);
            
            // Create a clipboard item with supported formats
            const clipboardItems = {};
            
            // Start timing
            const startTime = performance.now();
            
            try {
                // Add formats to clipboard items
                for (const format of selectedFormats) {
                    let formatData = data;
                    
                    if (format === 'text/plain') {
                        // Get specific size for text/plain if available
                        const sizeElement = document.getElementById('format-text-plain-size');
                        if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                            const formatSize = parseInt(sizeElement.value) || 50;
                            formatData = generateDataOfSize(formatSize);
                            log(`Using custom size for text/plain: ${formatSize}MB`);
                        }
                        clipboardItems[format] = new Blob([formatData], { type: format });
                    } else if (format === 'text/html') {
                        // Get specific size for text/html if available
                        const sizeElement = document.getElementById('format-text-html-size');
                        if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                            const formatSize = parseInt(sizeElement.value) || 50;
                            formatData = generateDataOfSize(formatSize);
                            log(`Using custom size for text/html: ${formatSize}MB`);
                        }
                        clipboardItems[format] = new Blob([`<pre>${formatData}</pre>`], { type: format });
                    } else if (format.startsWith('web custom/')) {
                        try {
                            // Custom formats will likely fail, but we'll try
                            // Get specific size for custom formats if available
                            const sizeElement = document.getElementById('format-custom-size');
                            if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                                const formatSize = parseInt(sizeElement.value) || 50;
                                formatData = generateDataOfSize(formatSize);
                                log(`Using custom size for ${format}: ${formatSize}MB`);
                            }
                            clipboardItems[format] = new Blob([formatData], { type: format });
                            log(`Added custom format: ${format}`, "info");
                        } catch (e) {
                            log(`Failed to add custom format ${format}: ${e.message}`, "error");
                        }
                    }
                }
                
                // If we have standard formats, proceed with write
                await navigator.clipboard.write([
                    new ClipboardItem(clipboardItems)
                ]);
                
                // End timing
                const endTime = performance.now();
                const timeTaken = endTime - startTime;
                
                log(`Write completed in ${timeTaken.toFixed(2)} ms`, "success");
                log(`Number of formats used: ${Object.keys(clipboardItems).length}`);
                
                return timeTaken;
            } catch (error) {
                log(`Error writing to clipboard: ${error.message}`, "error");
                return null;
            }
        }

        // Function to read data from clipboard
        async function readFromClipboard() {
            log(`Reading data from clipboard...`);
            
            // Start timing
            const startTime = performance.now();
            
            try {
                // Read text from clipboard
                const clipboardData = await navigator.clipboard.read();

                const types = clipboardData[0].types;
                let sizeTotal = 0;
                const formatSizes = {}; // Store size of each format
                
                for (const type of types) {
                    const textBlob = await clipboardData[0].getType(type);
                    const sizeOfBlob = textBlob.size;
                    sizeTotal += sizeOfBlob;
                    
                    // Store format size in MB (using 2 bytes per character)
                    const sizeMB = (sizeOfBlob * 2 / (1024 * 1024)).toFixed(2);
                    formatSizes[type] = parseFloat(sizeMB);
                    
                    log(`Read ${sizeOfBlob} characters (${sizeMB} MB) from clipboard for type ${type}`);
                }
                
                const endTime = performance.now();
                log(`Clipboard types: ${types.join(', ')}`);

                const sizeMB = (sizeTotal * 2 / (1024 * 1024)).toFixed(2);
                // End timing
                const timeTaken = endTime - startTime;
                
                lastReadMB = sizeMB;
                lastReadTypes = types;
                lastReadTime = timeTaken;
                lastFormatSizes = formatSizes; // Store format sizes globally
                
                log(`Read ${sizeMB}MB data in ${timeTaken.toFixed(2)} ms`, "success");
                
                return { time: timeTaken, formatSizes: formatSizes };
            } catch (error) {
                log(`Error reading from clipboard: ${error.message}`, "error");
                return null;
            }
        }

        // Function to compare two write operations
        async function compareWrites(data) {
            log(`Starting first write operation...`);
            const firstTime = await writeDataToClipboard(data);
            
            if (!firstTime) {
                log(`First write failed, cannot continue comparison.`, "error");
                return;
            }
            
            log(`Waiting 2 seconds before second write...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            log(`Starting second write operation...`);
            const secondTime = await writeDataToClipboard(data);
            
            if (!secondTime) {
                log(`Second write failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = secondTime - firstTime;
            log(`Time difference: ${timeDifference.toFixed(2)} ms`, 
                timeDifference > 0 ? "info" : "success");
            log(`First write: ${firstTime.toFixed(2)} ms, Second write: ${secondTime.toFixed(2)} ms`);
            
            return { firstTime, secondTime, difference: timeDifference };
        }

        // Function to compare two read operations
        async function compareReads() {
            log(`Starting first read operation...`);
            const firstResult = await readFromClipboard();
            
            if (!firstResult) {
                log(`First read failed, cannot continue comparison.`, "error");
                return;
            }
            
            log(`Waiting 2 seconds before second read...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            log(`Starting second read operation...`);
            const secondResult = await readFromClipboard();
            
            if (!secondResult) {
                log(`Second read failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = secondResult.time - firstResult.time;
            log(`Time difference: ${timeDifference.toFixed(2)} ms`, 
                timeDifference > 0 ? "info" : "success");
            log(`First read: ${firstResult.time.toFixed(2)} ms, Second read: ${secondResult.time.toFixed(2)} ms`);
            
            return { 
                firstTime: firstResult.time,
                secondTime: secondResult.time,
                difference: timeDifference
            };
        }

        // Function to compare different clipboard reading scenarios
        async function compareReadingScenarios(data) {
            // Save current format selection
            const originalSettings = {
                textPlain: document.getElementById('format-text-plain').checked,
                textHtml: document.getElementById('format-text-html').checked,
                custom: document.getElementById('format-custom').checked,
                customCount: document.getElementById('custom-format-count').value
            };
            
            // First scenario: single format (text/plain only)
            document.getElementById('format-text-plain').checked = true;
            document.getElementById('format-text-html').checked = false;
            document.getElementById('format-custom').checked = false;
            
            log(`Scenario 1: Writing data with text/plain format only...`);
            await writeDataToClipboard(data);
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            log(`Scenario 1: Reading data with text/plain format only...`);
            const singleFormatResult = await readFromClipboard();
            
            if (!singleFormatResult) {
                log(`Scenario 1 failed, cannot continue comparison.`, "error");
                // Restore original settings
                restoreSettings();
                return;
            }
            
            // Wait before next test
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Second scenario: multiple formats
            document.getElementById('format-text-plain').checked = true;
            document.getElementById('format-text-html').checked = true;
            
            log(`Scenario 2: Writing data with multiple formats...`);
            await writeDataToClipboard(data);
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            log(`Scenario 2: Reading data with multiple formats...`);
            const multiFormatResult = await readFromClipboard();
            
            // Restore original settings
            document.getElementById('format-text-plain').checked = originalSettings.textPlain;
            document.getElementById('format-text-html').checked = originalSettings.textHtml;
            document.getElementById('format-custom').checked = originalSettings.custom;
            document.getElementById('custom-format-count').value = originalSettings.customCount;
            
            if (!multiFormatResult) {
                log(`Scenario 2 failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = multiFormatResult.time - singleFormatResult.time;
            log(`---------- SCENARIO COMPARISON ----------`, "info");
            log(`Single format read time: ${singleFormatResult.time.toFixed(2)} ms`);
            log(`Multiple format read time: ${multiFormatResult.time.toFixed(2)} ms`);
            log(`Difference: ${timeDifference.toFixed(2)} ms`);
            log(`Impact: Reading with multiple formats is ${Math.abs(timeDifference / singleFormatResult.time * 100).toFixed(2)}% ${timeDifference > 0 ? 'slower' : 'faster'}`);
            
            return { 
                singleFormatTime: singleFormatResult.time,
                multiFormatTime: multiFormatResult.time,
                difference: timeDifference,
                percentage: Math.abs(timeDifference / singleFormatResult.time * 100)
            };
        }

        // Function to record clipboard operation data
        function recordClipboardOperation() {
            
            const now = new Date();
            const sizeInMB = lastReadMB;
            const copyTimeMs = lastReadTime;
            const types = lastReadTypes;
            const formatSizes = lastFormatSizes;
            
            // Calculate throughput in MB per second
            const throughput = parseFloat(sizeInMB) / (copyTimeMs / 1000);
            
            // Get current machine info - user-provided or auto-detected
            const machineInfo = getCurrentMachineInfo();
            
            const record = {
                datetime: now.toISOString(),
                totalSizeMB: parseFloat(sizeInMB),
                copyTimeMs: copyTimeMs,
                types: types,
                formatSizes: formatSizes,
                sizePerType: parseFloat(sizeInMB) / types.length,
                throughput: throughput,
                highlighted: false,
                systemInfo: machineInfo // Use current machine info
            };
            
            clipboardRecords.push(record);
            
            log(`Record added: ${now.toLocaleTimeString()} - Size: ${sizeInMB}MB - Time: ${copyTimeMs.toFixed(2)}ms - Throughput: ${throughput.toFixed(2)} MB/s - Types: ${types.join(', ')}`, "success");
            log(`Total records: ${clipboardRecords.length}`);
            
            updateRecordsTable();
            scrollTableToBottom(); // Scroll to the bottom to show the new record
            saveRecordsToLocalStorage(); // Save to localStorage after adding record
            console.log("Clipboard Records:", clipboardRecords);
        }

        // Helper function to format format sizes for display
        function formatSizesDisplay(formatSizes) {
            if (!formatSizes || Object.keys(formatSizes).length === 0) {
                return 'N/A';
            }
            
            return Object.entries(formatSizes)
                .map(([format, size]) => `${format.split('/').pop()}: ${size} MB`)
                .join('<br>');
        }

        // Function to update the records table
        function updateRecordsTable() {
            const tableBody = document.getElementById('records-body');
            tableBody.innerHTML = '';
            
            clipboardRecords.forEach((record, index) => {
                const row = document.createElement('tr');
                
                if (record.highlighted) {
                    row.className = 'highlighted';
                }
                
                // Add seed styling if it's a seed record
                if (record.isSeedRecord || (record.systemInfo && record.systemInfo.formatted === "SEED")) {
                    row.className += ' seed-record';
                }
                
                const time = new Date(record.datetime);
                const timeFormatted = time.toLocaleTimeString();
                
                // Format the sizes of each format nicely for display
                const formatSizesHtml = formatSizesDisplay(record.formatSizes);
                
                // Handle system info display
                const systemInfoDisplay = record.systemInfo && record.systemInfo.formatted ? 
                    record.systemInfo.formatted : 
                    (systemInfo ? systemInfo.formatted : "Unknown System");
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${timeFormatted}</td>
                    <td>${record.totalSizeMB.toFixed(2)}</td>
                    <td>${record.copyTimeMs.toFixed(2)}</td>
                    <td>${record.throughput ? record.throughput.toFixed(2) : 'N/A'}</td>
                    <td>${record.types.length}</td>
                    <td>${record.sizePerType ? record.sizePerType.toFixed(2) : 'N/A'}</td>
                    <td>${formatSizesHtml}</td>
                    <td>${record.types.join(', ')}</td>
                    <td>${systemInfoDisplay}</td>
                    <td><input type="checkbox" class="highlight-checkbox" data-index="${index}" ${record.highlighted ? 'checked' : ''}></td>
                    <td>
                        <button class="delete-record" data-index="${index}">Delete</button>
                        <button class="run-again" data-index="${index}">Run again</button>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
            
            // Add event listeners to delete buttons
            document.querySelectorAll('.delete-record').forEach(button => {
                button.addEventListener('click', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    deleteRecord(index);
                });
            });
            
            // Add event listeners to "Run again" buttons
            document.querySelectorAll('.run-again').forEach(button => {
                button.addEventListener('click', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    runRecord(clipboardRecords[index]);
                });
            });
            
            // Add event listeners to highlight checkboxes
            document.querySelectorAll('.highlight-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    toggleHighlight(index, this.checked);
                });
            });
        }
        
        // Function to toggle highlight state for a record
        function toggleHighlight(index, isHighlighted) {
            if (index >= 0 && index < clipboardRecords.length) {
                clipboardRecords[index].highlighted = isHighlighted;
                
                // Update row appearance
                const tableRows = document.querySelectorAll('#records-body tr');
                if (tableRows[index]) {
                    if (isHighlighted) {
                        tableRows[index].classList.add('highlighted');
                    } else {
                        tableRows[index].classList.remove('highlighted');
                    }
                }
                
                // Save to localStorage
                saveRecordsToLocalStorage();
                
                log(`${isHighlighted ? 'Highlighted' : 'Unhighlighted'} record #${index + 1}`, "info");
            }
        }
        
        // Function to delete a specific record
        function deleteRecord(index) {
            if (index >= 0 && index < clipboardRecords.length) {
                const record = clipboardRecords[index];
                const time = new Date(record.datetime).toLocaleTimeString();
                
                // Remove the record from the array
                clipboardRecords.splice(index, 1);
                
                // Update the table
                updateRecordsTable();
                
                // Save to localStorage
                saveRecordsToLocalStorage();
                
                log(`Deleted record #${index + 1} from ${time}`, "info");
            } else {
                log(`Invalid record index: ${index}`, "error");
            }
        }

        // Function to export records as CSV
        function exportRecordsAsCSV() {
            // Filter out seed records before export
            const recordsToExport = clipboardRecords.filter(record => 
                !record.isSeedRecord && 
                (!record.systemInfo || record.systemInfo.formatted !== "SEED")
            );
            
            if (recordsToExport.length === 0) {
                log("No non-seed records to export", "error");
                return;
            }
            
            const headers = ['Timestamp', 'Size (MB)', 'Duration (ms)', 'Throughput (MB/s)', 'NumFormats', 'Size/Type (MB)', 'Format Sizes', 'Formats', 'Machine'];
            
            let csvContent = headers.join(',') + '\n';
            
            recordsToExport.forEach(record => {
                // Format sizes as JSON string for CSV (without base64 encoding)
                const formatSizesStr = record.formatSizes ? 
                    `"${JSON.stringify(record.formatSizes).replace(/"/g, '""')}"` : '"N/A"';
                
                // Get system info display string
                const systemInfoStr = record.systemInfo && record.systemInfo.formatted ? 
                    `"${record.systemInfo.formatted}"` : 
                    `"${systemInfo.formatted}"`;
                
                const row = [
                    record.datetime,
                    record.totalSizeMB.toFixed(2),
                    record.copyTimeMs.toFixed(2),
                    record.throughput ? record.throughput.toFixed(2) : 'N/A',
                    record.types.length,
                    record.sizePerType ? record.sizePerType.toFixed(2) : 'N/A',
                    formatSizesStr,
                    '"' + record.types.join('; ') + '"',
                    systemInfoStr
                ];
                csvContent += row.join(',') + '\n';
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `clipboard-records-${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            log(`Records exported as CSV (${recordsToExport.length} records, excluding seeded records)`, "success");
        }

        // Function to upload records as CSV to server
        function uploadRecordsToServer() {
            // Filter out seed records before upload
            const recordsToExport = clipboardRecords.filter(record => 
                !record.isSeedRecord && 
                (!record.systemInfo || record.systemInfo.formatted !== "SEED")
            );
            
            if (recordsToExport.length === 0) {
                log("No non-seed records to upload", "error");
                return;
            }
            
            const headers = ['Timestamp', 'Size (MB)', 'Duration (ms)', 'Throughput (MB/s)', 'NumFormats', 'Size/Type (MB)', 'Format Sizes', 'Formats', 'Machine'];
            
            let csvContent = headers.join(',') + '\n';
            
            recordsToExport.forEach(record => {
                // Format sizes as JSON string for CSV (without base64 encoding)
                const formatSizesStr = record.formatSizes ? 
                    `"${JSON.stringify(record.formatSizes).replace(/"/g, '""')}"` : '"N/A"';
                
                // Get system info display string
                const systemInfoStr = record.systemInfo && record.systemInfo.formatted ? 
                    `"${record.systemInfo.formatted}"` : 
                    `"${systemInfo.formatted}"`;
                
                const row = [
                    record.datetime,
                    record.totalSizeMB.toFixed(2),
                    record.copyTimeMs.toFixed(2),
                    record.throughput ? record.throughput.toFixed(2) : 'N/A',
                    record.types.length,
                    record.sizePerType ? record.sizePerType.toFixed(2) : 'N/A',
                    formatSizesStr,
                    '"' + record.types.join('; ') + '"',
                    systemInfoStr
                ];
                csvContent += row.join(',') + '\n';
            });
            
            // Create a Blob from the CSV content
            const blob = new Blob([csvContent], { type: 'text/csv' });
            
            // Create FormData for the upload
            const formData = new FormData();
            formData.append('file', blob, `clipboard-records-${new Date().toISOString().slice(0, 10)}.csv`);
            
            // Upload to server
            log("Uploading CSV file to server...", "info");
            
            fetch('http://20.244.33.135:5044/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server responded with status ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                log(`Successfully uploaded CSV with ${recordsToExport.length} records`, "success");
                log(`Server response: ${JSON.stringify(data)}`, "info");
            })
            .catch(error => {
                log(`Error uploading CSV: ${error.message}`, "error");
                log("Make sure the server is running at http://localhost:5044", "info");
            });
        }

        // Function to import records from CSV
        function importRecordsFromCSV(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    const lines = csvContent.split('\n');
                    
                    // Check if CSV has at least a header and one data row
                    if (lines.length < 2) {
                        log("Invalid CSV: file is empty or has no data rows", "error");
                        return;
                    }
                    
                    // Parse header to identify column positions
                    const headers = lines[0].split(',');
                    const colIndexes = {
                        timestamp: headers.indexOf('Timestamp'),
                        size: headers.indexOf('Size (MB)'),
                        duration: headers.indexOf('Duration (ms)'),
                        throughput: headers.indexOf('Throughput (MB/s)'),
                        numFormats: headers.indexOf('NumFormats'),
                        sizePerType: headers.indexOf('Size/Type (MB)'),
                        formatSizes: headers.indexOf('Format Sizes'),
                        formats: headers.indexOf('Formats'),
                        machine: headers.indexOf('Machine')
                    };
                    
                    // Check if required columns are present
                    if (colIndexes.timestamp === -1 || colIndexes.duration === -1 || colIndexes.formats === -1) {
                        log("Invalid CSV: missing required columns (Timestamp, Duration, Formats)", "error");
                        return;
                    }
                    
                    // Process data rows
                    let importedRecords = [];
                    let skippedRows = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue; // Skip empty lines
                        
                        try {
                            // Parse the CSV line properly handling quoted fields
                            const values = parseCSVLine(line);
                            
                            // Parse timestamp
                            const timestamp = values[colIndexes.timestamp]?.replace(/"/g, '') || '';
                            if (!timestamp) {
                                throw new Error("Missing timestamp");
                            }
                            
                            // Parse formats
                            const formatsStr = values[colIndexes.formats]?.replace(/"/g, '') || '';
                            const types = formatsStr.split(';').map(type => type.trim()).filter(type => type);
                            
                            // Parse format sizes if available
                            let formatSizes = {};
                            if (colIndexes.formatSizes !== -1 && values[colIndexes.formatSizes]) {
                                try {
                                    // Get the raw format sizes string
                                    let formatSizesStr = values[colIndexes.formatSizes];
                                    
                                    // Remove surrounding quotes if present
                                    if (formatSizesStr.startsWith('"') && formatSizesStr.endsWith('"')) {
                                        formatSizesStr = formatSizesStr.substring(1, formatSizesStr.length - 1);
                                    }
                                    
                                    // Restore double quotes in JSON that were escaped as "" in CSV
                                    formatSizesStr = formatSizesStr.replace(/""/g, '"');
                                    
                                    if (formatSizesStr && formatSizesStr.toLowerCase() !== 'n/a') {
                                        try {
                                            // First try to parse as regular JSON
                                            formatSizes = JSON.parse(formatSizesStr);
                                        } catch (jsonErr) {
                                            try {
                                                // Next, try to decode as base64 (for backward compatibility)
                                                const decoded = atob(formatSizesStr);
                                                formatSizes = JSON.parse(decoded);
                                            } catch (decodeErr) {
                                                // Last resort: try to fix common JSON issues
                                                log(`Attempting to repair malformed JSON: ${formatSizesStr.substring(0, 50)}...`, "info");
                                                const repaired = formatSizesStr
                                                    .replace(/;/g, ',')         // Replace semicolons with commas
                                                    .replace(/'/g, '"')         // Replace single quotes with double quotes
                                                    .replace(/([{,]\s*)(\w+):/g, '$1"$2":'); // Add quotes to keys
                                                
                                                formatSizes = JSON.parse(repaired);
                                            }
                                        }
                                    }
                                } catch (e) {
                                    log(`Error parsing format sizes for row ${i}: ${e.message}`, "error");
                                    formatSizes = {}; // Continue with empty formatSizes
                                }
                            }
                            
                            // Parse machine info if available
                            const machineStr = values[colIndexes.machine]?.replace(/"/g, '').trim() || '';
                            let recordSystemInfo = null;
                            if (machineStr && machineStr !== 'N/A') {
                                const parts = machineStr.split(',').map(part => part.trim());
                                recordSystemInfo = {
                                    os: parts[0] || "Unknown OS",
                                    ram: parts.length > 1 ? parts[1] : "Unknown",
                                    cpu: parts.length > 2 ? parts[2] : "Unknown",
                                    formatted: machineStr,
                                    userProvided: true
                                };
                            }
                            
                            // Create record object
                            const record = {
                                datetime: timestamp,
                                totalSizeMB: parseFloat(values[colIndexes.size]) || 0,
                                copyTimeMs: parseFloat(values[colIndexes.duration]) || 0,
                                types: types,
                                formatSizes: formatSizes,
                                sizePerType: parseFloat(values[colIndexes.sizePerType]) || 0,
                                throughput: parseFloat(values[colIndexes.throughput]) || 0,
                                highlighted: false,
                                systemInfo: recordSystemInfo || systemInfo // Use current system info if not available
                            };
                            
                            importedRecords.push(record);
                        } catch (e) {
                            skippedRows++;
                            log(`Error parsing row ${i}: ${e.message}`, "error");
                        }
                    }
                    
                    if (importedRecords.length === 0) {
                        log("No valid records found in CSV file", "error");
                        return;
                    }
                    
                    // Add imported records to clipboardRecords
                    clipboardRecords = [...clipboardRecords, ...importedRecords];
                    
                    // Update the table
                    updateRecordsTable();
                    
                    // Save to localStorage
                    saveRecordsToLocalStorage();
                    
                    log(`Successfully imported ${importedRecords.length} records from CSV`, "success");
                    if (skippedRows > 0) {
                        log(`Skipped ${skippedRows} invalid rows during import`, "info");
                    }
                    
                } catch (e) {
                    log(`Error importing CSV: ${e.message}`, "error");
                }
            };
            
            reader.onerror = function() {
                log("Error reading the CSV file", "error");
            };
            
            reader.readAsText(file);
        }
        
        // Helper function to properly parse a CSV line with quoted fields
        function parseCSVLine(line) {
            const result = [];
            let inQuote = false;
            let currentValue = '';
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuote && nextChar === '"') {
                        // Handle escaped quotes ("") inside quoted fields
                        currentValue += '"';
                        i++;  // Skip the next quote
                    } else {
                        // Toggle quote mode
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    // End of field
                    result.push(currentValue);
                    currentValue = '';
                } else {
                    // Regular character
                    currentValue += char;
                }
                
                i++;
            }
            
            // Add the last field
            result.push(currentValue);
            
            return result;
        }

        document.getElementById('export-records').addEventListener('click', () => {
            saveRecordsToLocalStorage(); // Ensure latest records are saved
            exportRecordsAsCSV();
        });
        
        // Add event listener for import CSV button
        document.getElementById('import-records').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });
        
        // Add event listener for file input change
        document.getElementById('csv-file-input').addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                importRecordsFromCSV(this.files[0]);
                // Reset the file input so the same file can be selected again
                this.value = '';
            }
        });

        // Function to save records to localStorage
        function saveRecordsToLocalStorage() {
            localStorage.setItem('clipboardRecords', JSON.stringify(clipboardRecords));
            log("Records saved to localStorage", "info");
        }
        
        // Function to load records from localStorage
        function loadRecordsFromLocalStorage() {
            try {
                const storedRecords = localStorage.getItem('clipboardRecords');
                if (storedRecords) {
                    clipboardRecords = JSON.parse(storedRecords);
                    log(`Loaded ${clipboardRecords.length} records from localStorage`, "success");
                    updateRecordsTable();
                } else {
                    log("No records found in localStorage", "info");
                }
            } catch (e) {
                log(`Error loading records from localStorage: ${e.message}`, "error");
                console.error("Failed to parse stored records:", e);
            }
        }

        // Function to log messages on the HTML page
        function log(message, type = "default", replace = false) {
            const logContainer = document.getElementById('log-container');
            let entry;
            
            if (replace && logContainer.lastChild) {
                entry = logContainer.lastChild;
            } else {
                entry = document.createElement('div');
                entry.className = 'log-entry';
                logContainer.appendChild(entry);
            }
            
            if (type !== "default") {
                entry.className = `log-entry ${type}`;
            }
            
            const timestamp = new Date().toTimeString().substr(0, 8);
            entry.textContent = `[${timestamp}] ${message}`;
            
            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Function to load seeded records into the table
        function loadSeededRecords() {
            if (seededClipboardRecords && seededClipboardRecords.length > 0) {
                // Deep copy seeded records but modify machine info to "SEED"
                clipboardRecords = JSON.parse(JSON.stringify(seededClipboardRecords)).map(record => {
                    // Mark record as seeded by setting machine info to "SEED"
                    return {
                        ...record,
                        systemInfo: {
                            os: "SEED",
                            ram: "SEED",
                            cpu: "SEED",
                            formatted: "SEED",
                            userProvided: true
                        },
                        isSeedRecord: true // Add flag to identify seed records
                    };
                });
                
                updateRecordsTable();
                saveRecordsToLocalStorage();
                log(`Loaded ${clipboardRecords.length} seeded records`, "success");
                log(`These records are marked with machine name "SEED" and will be excluded from CSV exports`, "info");
                
                // Scroll table to bottom after loading seeds
                scrollTableToBottom();
            } else {
                log("No seeded records found", "error");
            }
        }
        
        // Function to scroll the records table to the bottom
        function scrollTableToBottom() {
            const recordsContainer = document.querySelector('.records-container');
            recordsContainer.scrollTop = recordsContainer.scrollHeight;
        }

        // Function to copy current records table as JS code for seeding
        function copyRecordsAsJSCode() {
            if (clipboardRecords.length === 0) {
                log("No records to copy", "error");
                return;
            }
            
            try {
                // Format the records as a pretty-printed JavaScript array literal
                const jsCode = `const seededClipboardRecords = ${JSON.stringify(clipboardRecords, null, 4)};`;
                
                // Copy to clipboard
                navigator.clipboard.writeText(jsCode)
                    .then(() => {
                        log(`Copied code for ${clipboardRecords.length} records to clipboard`, "success");
                        log("Paste this code into your HTML file to replace the seededClipboardRecords array", "info");
                    })
                    .catch(err => {
                        log(`Failed to copy to clipboard: ${err.message}`, "error");
                    });
            } catch (e) {
                log(`Error formatting records as JS code: ${e.message}`, "error");
            }
        }

        // Event listeners
        document.getElementById('write-btn').addEventListener('click', async () => {
            const currentSize = parseInt(document.getElementById('data-size').value) || 50;
            
            // Generate data if it doesn't exist or if the size has changed
            if (!generatedData || currentSize !== lastGeneratedSize) {
                log(`Data size changed from ${lastGeneratedSize}MB to ${currentSize}MB, regenerating data...`);
                lastGeneratedSize = currentSize;
                generatedData = generateDataOfSize(currentSize);
            }
            
            // Save previous write time if exists
            if (lastWriteTime) {
                previousWriteTime = lastWriteTime;
            }
            
            lastWriteTime = await writeDataToClipboard(generatedData);
        });

        document.getElementById('read-btn').addEventListener('click', async () => {
            const result = await readFromClipboard();
            
            if (result) {
                // Save previous read time if exists
                if (lastReadTime) {
                    previousReadTime = lastReadTime;
                }
                
                lastReadTime = result.time;
            }
        });

        document.getElementById('record-btn').addEventListener('click', () => {
            recordClipboardOperation();
        });

        document.getElementById('clear-log').addEventListener('click', () => {
            document.getElementById('log-container').innerHTML = '';
            log("Log cleared");
        });
        
        // Records management button event listeners
        document.getElementById('clear-records').addEventListener('click', () => {
            clipboardRecords = [];
            updateRecordsTable();
            localStorage.removeItem('clipboardRecords'); // Remove from localStorage
            log("Records cleared", "info");
        });
        
        document.getElementById('export-records').addEventListener('click', () => {
            saveRecordsToLocalStorage(); // Ensure latest records are saved
            exportRecordsAsCSV();
        });
        
        // Add event listener for import CSV button
        document.getElementById('import-records').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });
        
        // Add event listener for file input change
        document.getElementById('csv-file-input').addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                importRecordsFromCSV(this.files[0]);
                // Reset the file input so the same file can be selected again
                this.value = '';
            }
        });

        // Function to run an experiment with specified format sizes
        async function runExperiment(sizesDictionary) {
            // Save original settings to restore later
            const originalSettings = {
                textPlain: document.getElementById('format-text-plain').checked,
                textPlainSize: document.getElementById('format-text-plain-size').value,
                textHtml: document.getElementById('format-text-html').checked,
                textHtmlSize: document.getElementById('format-text-html-size').value,
                custom: document.getElementById('format-custom').checked,
                customCount: document.getElementById('custom-format-count').value,
                customSize: document.getElementById('format-custom-size').value,
                defaultSize: document.getElementById('data-size').value
            };
            
            log("Starting experiment with specified format sizes...", "info");
            
            try {
                // Configure formats based on the dictionary
                document.getElementById('format-text-plain').checked = sizesDictionary.hasOwnProperty('text/plain');
                if (sizesDictionary['text/plain']) {
                    document.getElementById('format-text-plain-size').value = sizesDictionary['text/plain'];
                }
                
                document.getElementById('format-text-html').checked = sizesDictionary.hasOwnProperty('text/html');
                if (sizesDictionary['text/html']) {
                    document.getElementById('format-text-html-size').value = sizesDictionary['text/html'];
                }
                
                const customFormats = Object.keys(sizesDictionary).filter(key => key.startsWith('web custom/'));
                document.getElementById('format-custom').checked = customFormats.length > 0;
                if (customFormats.length > 0) {
                    document.getElementById('custom-format-count').value = customFormats.length;
                    document.getElementById('format-custom-size').value = sizesDictionary[customFormats[0]];
                }
                
                // Find the largest size for data generation
                const maxSize = Math.max(...Object.values(sizesDictionary));
                document.getElementById('data-size').value = maxSize;
                
                // Generate data based on the largest size
                log(`Generating data for experiment (max size: ${maxSize} MB)...`);
                const generatedData = generateDataOfSize(maxSize);
                
                // Write to clipboard
                log("Writing to clipboard with configured formats...");
                const writeTime = await writeDataToClipboard(generatedData);
                
                if (writeTime) {
                    // Wait a moment before reading
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Read from clipboard
                    log("Reading from clipboard...");
                    const readResult = await readFromClipboard();
                    
                    if (readResult) {
                        // Record the operation
                        log("Recording experiment results...");
                        recordClipboardOperation(); // This will also scroll the table to the bottom
                    }
                }
            } catch (error) {
                log(`Error during experiment: ${error.message}`, "error");
            } finally {
                // Restore original settings
                document.getElementById('format-text-plain').checked = originalSettings.textPlain;
                document.getElementById('format-text-plain-size').value = originalSettings.textPlainSize;
                document.getElementById('format-text-html').checked = originalSettings.textHtml;
                document.getElementById('format-text-html-size').value = originalSettings.textHtmlSize;
                document.getElementById('format-custom').checked = originalSettings.custom;
                document.getElementById('custom-format-count').value = originalSettings.customCount;
                document.getElementById('format-custom-size').value = originalSettings.customSize;
                document.getElementById('data-size').value = originalSettings.defaultSize;
                
                log("Experiment completed and original settings restored", "success");
                scrollTableToBottom(); // Ensure the table is scrolled to bottom after experiment
            }
        }

        document.getElementById('run-experiment-btn').addEventListener('click', () => {
            // Get sizes dictionary from UI values
            const sizesDictionary = {};
            
            // Add text/plain format if selected
            if (document.getElementById('format-text-plain').checked) {
                const size = parseInt(document.getElementById('format-text-plain-size').value) || 50;
                sizesDictionary['text/plain'] = size;
            }
            
            // Add text/html format if selected
            if (document.getElementById('format-text-html').checked) {
                const size = parseInt(document.getElementById('format-text-html-size').value) || 50;
                sizesDictionary['text/html'] = size;
            }
            
            // Add custom formats if selected
            if (document.getElementById('format-custom').checked) {
                const count = parseInt(document.getElementById('custom-format-count').value) || 1;
                const size = parseInt(document.getElementById('format-custom-size').value) || 50;
                
                for (let i = 1; i <= count; i++) {
                    sizesDictionary[`web custom/format-${i}`] = size;
                }
            }
            
            // Log the configuration
            log(`Experiment configuration: ${JSON.stringify(sizesDictionary)}`, "info");
            
            runExperiment(sizesDictionary);
        });

        // Function to run an experiment based on a previous record
        function runRecord(record) {
            if (!record || !record.formatSizes) {
                log("Cannot run experiment: record or format sizes not available", "error");
                return;
            }
            
            log(`Running experiment based on record from ${new Date(record.datetime).toLocaleTimeString()}...`, "info");
            
            // Convert record's formatSizes to a sizesDictionary for runExperiment
            const sizesDictionary = {};
            
            // Process each format and its size from the record
            Object.entries(record.formatSizes).forEach(([format, size]) => {
                sizesDictionary[format] = size;
            });
            
            // Check if we have any valid formats
            if (Object.keys(sizesDictionary).length === 0) {
                log("No valid formats found in the record", "error");
                return;
            }
            
            // Update UI elements to match the record's format sizes
            document.getElementById('format-text-plain').checked = sizesDictionary.hasOwnProperty('text/plain');
            if (sizesDictionary['text/plain']) {
                document.getElementById('format-text-plain-size').value = sizesDictionary['text/plain'];
            }
            
            document.getElementById('format-text-html').checked = sizesDictionary.hasOwnProperty('text/html');
            if (sizesDictionary['text/html']) {
                document.getElementById('format-text-html-size').value = sizesDictionary['text/html'];
            }
            
            const customFormats = Object.keys(sizesDictionary).filter(key => key.startsWith('web custom/'));
            document.getElementById('format-custom').checked = customFormats.length > 0;
            if (customFormats.length > 0) {
                document.getElementById('custom-format-count').value = customFormats.length;
                document.getElementById('format-custom-size').value = sizesDictionary[customFormats[0]];
            }
            
            // Find the largest size for data size field
            const maxSize = Math.max(...Object.values(sizesDictionary));
            document.getElementById('data-size').value = maxSize;
            
            log(`Recreating experiment with formats: ${Object.keys(sizesDictionary).join(', ')}`, "info");
            log(`UI updated with sizes: ${JSON.stringify(sizesDictionary)}`, "info");
            
            // Run the experiment with the extracted sizes
            runExperiment(sizesDictionary);
        }
        
        // Function to run experiments for all records (creating new records)
        async function rerunAllExperiments() {
            if (clipboardRecords.length === 0) {
                log("No records to rerun", "error");
                return;
            }
            
            log(`Starting to re-run experiments for all ${clipboardRecords.length} records...`, "info");
            
            // Disable the button while running
            const rerunAllNewBtn = document.getElementById('rerun-all-new-btn');
            rerunAllNewBtn.disabled = true;
            rerunAllNewBtn.textContent = "Running...";

            const tmpRecords = [...clipboardRecords]; // Create a copy of the records to avoid modifying the original array
            
            try {
                // Process each record in sequence
                for (let i = 0; i < tmpRecords.length; i++) {
                    const record = tmpRecords[i];
                    log(`Re-running experiment ${i+1} of ${tmpRecords.length}...`, "info");
                    
                    // Convert record's formatSizes to a sizesDictionary for runExperiment
                    const sizesDictionary = {};
                    
                    // Process each format and its size from the record
                    Object.entries(record.formatSizes).forEach(([format, size]) => {
                        sizesDictionary[format] = size;
                    });
                    
                    if (Object.keys(sizesDictionary).length === 0) {
                        log(`Skipping record ${i+1}: no valid formats found`, "error");
                        continue;
                    }
                    
                    // Run the experiment with the extracted sizes - this will create a new record
                    await runExperiment(sizesDictionary);
                    
                    // Add a small delay between experiments
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                log(`Completed re-running experiments for all ${tmpRecords.length} records`, "success");
            } catch (error) {
                log(`Error during re-run all experiments: ${error.message}`, "error");
            } finally {
                // Re-enable the button
                rerunAllNewBtn.disabled = false;
                rerunAllNewBtn.textContent = "Re-run all (new)";
            }
        }

        // Initial log message
        log("Clipboard Performance Test initialized");
        log("Steps: 1) Set data size and formats, 2) Write to clipboard, 3) Read and record results");

        // Load records from localStorage
        loadRecordsFromLocalStorage();

        // Check if running in secure context (required for clipboard API)
        if (!window.isSecureContext) {
            log("Warning: This page is not running in a secure context. Clipboard API may be limited.", "error");
        }

        // Load records from localStorage on page load
        loadRecordsFromLocalStorage();
        scrollTableToBottom(); // Scroll to bottom when loading initial records

        // Save records to localStorage before page unload
        window.addEventListener('beforeunload', saveRecordsToLocalStorage);

        // Add event listener for "Rerun All" button
        document.getElementById('rerun-all-btn').addEventListener('click', () => {
            rerunAllRecords();
        });
        
        // Add event listener for "Re-run all (new)" button
        document.getElementById('rerun-all-new-btn').addEventListener('click', () => {
            rerunAllExperiments();
        });

        document.getElementById('import-records').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });

        // Add event listener for auto-detect button
        document.getElementById('detect-machine-btn').addEventListener('click', () => {
            // Get system information and update the input field
            const detectedInfo = getSystemInfo();
            document.getElementById('machine-details').value = detectedInfo.formatted;
            log("Machine details auto-detected", "info");
        });

        // Add event listener for "Load Seed" button
        document.getElementById('load-seed-btn').addEventListener('click', () => {
            loadSeededRecords();
        });
        
        // Add event listener for "Copy table for seed" button
        document.getElementById('copy-for-seed-btn').addEventListener('click', () => {
            copyRecordsAsJSCode();
        });

        // Add event listener for "Upload CSV" button
        document.getElementById('upload-csv-btn').addEventListener('click', () => {
            uploadRecordsToServer();
        });
    </script>
</body>
</html>