<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clipboard Performance Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1800px; /* Increased from 1200px */
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .left-column {
            flex: 2; /* Increased from 1 to give more space to left column */
        }
        .right-column {
            flex: 3; /* Increased from 1 to give more space to right column */
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            margin: 5px;
            padding: 8px 16px;
        }
        .button-group {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background-color: #f5f5f5;
        }
        .group-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .format-options {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            background-color: #f9f9f9;
        }
        .format-option {
            margin: 5px 0;
        }
        #log-container {
            border: 1px solid #ccc;
            padding: 10px;
            height: 400px;
            overflow-y: auto;
            background-color: #f9f9f9;
            font-family: monospace;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #eee;
        }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .custom-format-count {
            width: 60px;
            margin-left: 10px;
        }
        /* Table Styles */
        .records-container {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
            height: 600px;
            overflow-y: auto;
        }
        .records-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .records-table {
            width: 100%;
            border-collapse: collapse;
        }
        .records-table th,
        .records-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .records-table th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        .records-table tr:nth-child(even) {
            background-color: #f5f5f5;
        }
        .records-table tr:hover {
            background-color: #e9e9e9;
        }
        .records-actions {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
        }
        .records-table tr.highlighted {
            background-color: #ffffc0 !important; /* Light yellow highlight */
            font-weight: bold;
        }
        .highlight-checkbox {
            margin-right: 5px;
        }
        .format-size {
            width: 60px;
            margin-left: 10px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <h1>Clipboard Performance Test</h1>

    <div class="container">
        <div class="left-column">
            <div class="controls">
                <div>
                    <label for="data-size">Default Data Size (MB): </label>
                    <input type="number" id="data-size" value="50" min="1" max="100">
                </div>
                
                <div class="format-options">
                    <div class="group-title">Clipboard Format Options:</div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-text-plain" checked>
                        <label for="format-text-plain">text/plain</label>
                        <input type="number" id="format-text-plain-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-text-plain-size">MB</label>
                    </div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-text-html">
                        <label for="format-text-html">text/html</label>
                        <input type="number" id="format-text-html-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-text-html-size">MB</label>
                    </div>
                    
                    <div class="format-option">
                        <input type="checkbox" id="format-custom">
                        <label for="format-custom">Custom formats</label>
                        <input type="number" id="custom-format-count" class="custom-format-count" value="1" min="1" max="10">
                        <label for="custom-format-count">count</label>
                        <input type="number" id="format-custom-size" class="format-size" value="50" min="1" max="100">
                        <label for="format-custom-size">MB</label>
                    </div>
                </div>
                
                <div class="button-group">
                    <div class="group-title">Write Operations</div>
                    <button id="write-btn">Write to Clipboard</button>
                    <button id="run-experiment-btn">Run Experiment</button>
                </div>
                
                <div class="button-group">
                    <div class="group-title">Read Operations</div>
                    <button id="read-btn">Read from Clipboard</button>
                </div>

                <button id="clear-log">Clear Log</button>
            </div>

            <div id="log-container"></div>
        </div>
        
        <div class="right-column">
            <div class="records-container">
                <div class="records-title">Clipboard Records</div>
                <div class="records-actions">
                    <button id="clear-records">Clear Records</button>
                    <button id="record-btn">Record</button>
                    <button id="export-records">Export as CSV</button>
                    <button id="import-records">Import CSV</button>
                    <button id="rerun-all-btn">Rerun All</button>
                    <button id="rerun-all-new-btn">Re-run all (new)</button>
                    <input type="file" id="csv-file-input" accept=".csv" style="display: none;">
                </div>
                <table class="records-table" id="records-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Time</th>
                            <th>Size (MB)</th>
                            <th>Duration (ms)</th>
                            <th>Throughput (MB/s)</th>
                            <th>NumFormats</th>
                            <th>Size/Type (MB)</th>
                            <th>Format Sizes</th>
                            <th>Formats</th>
                            <th>Highlight</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="records-body">
                        <!-- Record rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let generatedData = '';
        let lastWriteTime = 0;
        let previousWriteTime = 0;
        let lastReadTypes = [];
        let lastReadTime = 0;
        let lastReadMB = 0;
        let previousReadTime = 0;
        let lastGeneratedSize = 0; // Track the last generated data size
        let lastFormatSizes = {}; // Track last read format sizes
        let clipboardRecords = []; // New array to store records

        // Function to generate data of specified size in MB
        function generateDataOfSize(sizeInMB) {
            const bytesPerMB = 1024 * 1024;
            const targetBytes = sizeInMB * bytesPerMB;
            
            log(`Generating ${sizeInMB} MB of data...`);
            
            // Creating data in chunks to avoid memory issues
            const chunkSize = 1024 * 1024; // 1MB chunks
            let result = '';
            
            // Each character in JavaScript is 2 bytes
            const totalChars = targetBytes / 2;
            const chunksNeeded = Math.ceil(totalChars / chunkSize);
            
            for (let i = 0; i < chunksNeeded; i++) {
                const remainingChars = Math.min(chunkSize, totalChars - result.length);
                result += 'A'.repeat(remainingChars);
                
                if (i % 5 === 0 || i === chunksNeeded - 1) {
                    // Update progress every 5 chunks or at the end
                    const progress = Math.round((result.length / totalChars) * 100);
                    log(`Generation progress: ${progress}%`, "info", true);
                }
            }
            
            log(`Data generated: ${(result.length * 2 / bytesPerMB).toFixed(2)} MB`, "success");
            return result;
        }

        // Function to get selected formats
        function getSelectedFormats() {
            const formats = [];
            if (document.getElementById('format-text-plain').checked) {
                formats.push('text/plain');
            }
            if (document.getElementById('format-text-html').checked) {
                formats.push('text/html');
            }
            
            const useCustomFormats = document.getElementById('format-custom').checked;
            if (useCustomFormats) {
                const count = parseInt(document.getElementById('custom-format-count').value) || 1;
                for (let i = 1; i <= count; i++) {
                    formats.push(`web custom/format-${i}`);
                }
            }
            
            return formats;
        }

        // Function to write data to clipboard in selected formats
        async function writeDataToClipboard(data) {
            const selectedFormats = getSelectedFormats();
            
            if (selectedFormats.length === 0) {
                log("Please select at least one format!", "error");
                return null;
            }
            
            log(`Writing ${(data.length * 2 / (1024 * 1024)).toFixed(2)} MB of data to clipboard in ${selectedFormats.length} formats...`);
            log(`Formats: ${selectedFormats.join(', ')}`);
            
            // Create a clipboard item with supported formats
            const clipboardItems = {};
            
            // Start timing
            const startTime = performance.now();
            
            try {
                // Add formats to clipboard items
                for (const format of selectedFormats) {
                    let formatData = data;
                    
                    if (format === 'text/plain') {
                        // Get specific size for text/plain if available
                        const sizeElement = document.getElementById('format-text-plain-size');
                        if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                            const formatSize = parseInt(sizeElement.value) || 50;
                            formatData = generateDataOfSize(formatSize);
                            log(`Using custom size for text/plain: ${formatSize}MB`);
                        }
                        clipboardItems[format] = new Blob([formatData], { type: format });
                    } else if (format === 'text/html') {
                        // Get specific size for text/html if available
                        const sizeElement = document.getElementById('format-text-html-size');
                        if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                            const formatSize = parseInt(sizeElement.value) || 50;
                            formatData = generateDataOfSize(formatSize);
                            log(`Using custom size for text/html: ${formatSize}MB`);
                        }
                        clipboardItems[format] = new Blob([`<pre>${formatData}</pre>`], { type: format });
                    } else if (format.startsWith('web custom/')) {
                        try {
                            // Custom formats will likely fail, but we'll try
                            // Get specific size for custom formats if available
                            const sizeElement = document.getElementById('format-custom-size');
                            if (sizeElement && sizeElement.value !== document.getElementById('data-size').value) {
                                const formatSize = parseInt(sizeElement.value) || 50;
                                formatData = generateDataOfSize(formatSize);
                                log(`Using custom size for ${format}: ${formatSize}MB`);
                            }
                            clipboardItems[format] = new Blob([formatData], { type: format });
                            log(`Added custom format: ${format}`, "info");
                        } catch (e) {
                            log(`Failed to add custom format ${format}: ${e.message}`, "error");
                        }
                    }
                }
                
                // If we have standard formats, proceed with write
                if (clipboardItems['text/plain'] || clipboardItems['text/html']) {
                    await navigator.clipboard.write([
                        new ClipboardItem(clipboardItems)
                    ]);
                    
                    // End timing
                    const endTime = performance.now();
                    const timeTaken = endTime - startTime;
                    
                    log(`Write completed in ${timeTaken.toFixed(2)} ms`, "success");
                    log(`Number of formats used: ${Object.keys(clipboardItems).length}`);
                    
                    return timeTaken;
                } else {
                    throw new Error("At least one of text/plain or text/html is required");
                }
            } catch (error) {
                log(`Error writing to clipboard: ${error.message}`, "error");
                return null;
            }
        }

        // Function to read data from clipboard
        async function readFromClipboard() {
            log(`Reading data from clipboard...`);
            
            // Start timing
            const startTime = performance.now();
            
            try {
                // Read text from clipboard
                const clipboardData = await navigator.clipboard.read();

                const types = clipboardData[0].types;
                let sizeTotal = 0;
                const formatSizes = {}; // Store size of each format
                
                for (const type of types) {
                    const textBlob = await clipboardData[0].getType(type);
                    const sizeOfBlob = textBlob.size;
                    sizeTotal += sizeOfBlob;
                    
                    // Store format size in MB (using 2 bytes per character)
                    const sizeMB = (sizeOfBlob * 2 / (1024 * 1024)).toFixed(2);
                    formatSizes[type] = parseFloat(sizeMB);
                    
                    log(`Read ${sizeOfBlob} characters (${sizeMB} MB) from clipboard for type ${type}`);
                }
                
                const endTime = performance.now();
                log(`Clipboard types: ${types.join(', ')}`);

                const sizeMB = (sizeTotal * 2 / (1024 * 1024)).toFixed(2);
                // End timing
                const timeTaken = endTime - startTime;
                
                lastReadMB = sizeMB;
                lastReadTypes = types;
                lastReadTime = timeTaken;
                lastFormatSizes = formatSizes; // Store format sizes globally
                
                log(`Read ${sizeMB}MB data in ${timeTaken.toFixed(2)} ms`, "success");
                
                return { time: timeTaken, formatSizes: formatSizes };
            } catch (error) {
                log(`Error reading from clipboard: ${error.message}`, "error");
                return null;
            }
        }

        // Function to compare two write operations
        async function compareWrites(data) {
            log(`Starting first write operation...`);
            const firstTime = await writeDataToClipboard(data);
            
            if (!firstTime) {
                log(`First write failed, cannot continue comparison.`, "error");
                return;
            }
            
            log(`Waiting 2 seconds before second write...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            log(`Starting second write operation...`);
            const secondTime = await writeDataToClipboard(data);
            
            if (!secondTime) {
                log(`Second write failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = secondTime - firstTime;
            log(`Time difference: ${timeDifference.toFixed(2)} ms`, 
                timeDifference > 0 ? "info" : "success");
            log(`First write: ${firstTime.toFixed(2)} ms, Second write: ${secondTime.toFixed(2)} ms`);
            
            return { firstTime, secondTime, difference: timeDifference };
        }

        // Function to compare two read operations
        async function compareReads() {
            log(`Starting first read operation...`);
            const firstResult = await readFromClipboard();
            
            if (!firstResult) {
                log(`First read failed, cannot continue comparison.`, "error");
                return;
            }
            
            log(`Waiting 2 seconds before second read...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            log(`Starting second read operation...`);
            const secondResult = await readFromClipboard();
            
            if (!secondResult) {
                log(`Second read failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = secondResult.time - firstResult.time;
            log(`Time difference: ${timeDifference.toFixed(2)} ms`, 
                timeDifference > 0 ? "info" : "success");
            log(`First read: ${firstResult.time.toFixed(2)} ms, Second read: ${secondResult.time.toFixed(2)} ms`);
            
            return { 
                firstTime: firstResult.time,
                secondTime: secondResult.time,
                difference: timeDifference
            };
        }

        // Function to compare different clipboard reading scenarios
        async function compareReadingScenarios(data) {
            // Save current format selection
            const originalSettings = {
                textPlain: document.getElementById('format-text-plain').checked,
                textHtml: document.getElementById('format-text-html').checked,
                custom: document.getElementById('format-custom').checked,
                customCount: document.getElementById('custom-format-count').value
            };
            
            // First scenario: single format (text/plain only)
            document.getElementById('format-text-plain').checked = true;
            document.getElementById('format-text-html').checked = false;
            document.getElementById('format-custom').checked = false;
            
            log(`Scenario 1: Writing data with text/plain format only...`);
            await writeDataToClipboard(data);
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            log(`Scenario 1: Reading data with text/plain format only...`);
            const singleFormatResult = await readFromClipboard();
            
            if (!singleFormatResult) {
                log(`Scenario 1 failed, cannot continue comparison.`, "error");
                // Restore original settings
                restoreSettings();
                return;
            }
            
            // Wait before next test
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Second scenario: multiple formats
            document.getElementById('format-text-plain').checked = true;
            document.getElementById('format-text-html').checked = true;
            
            log(`Scenario 2: Writing data with multiple formats...`);
            await writeDataToClipboard(data);
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            log(`Scenario 2: Reading data with multiple formats...`);
            const multiFormatResult = await readFromClipboard();
            
            // Restore original settings
            document.getElementById('format-text-plain').checked = originalSettings.textPlain;
            document.getElementById('format-text-html').checked = originalSettings.textHtml;
            document.getElementById('format-custom').checked = originalSettings.custom;
            document.getElementById('custom-format-count').value = originalSettings.customCount;
            
            if (!multiFormatResult) {
                log(`Scenario 2 failed, cannot complete comparison.`, "error");
                return;
            }
            
            const timeDifference = multiFormatResult.time - singleFormatResult.time;
            log(`---------- SCENARIO COMPARISON ----------`, "info");
            log(`Single format read time: ${singleFormatResult.time.toFixed(2)} ms`);
            log(`Multiple format read time: ${multiFormatResult.time.toFixed(2)} ms`);
            log(`Difference: ${timeDifference.toFixed(2)} ms`);
            log(`Impact: Reading with multiple formats is ${Math.abs(timeDifference / singleFormatResult.time * 100).toFixed(2)}% ${timeDifference > 0 ? 'slower' : 'faster'}`);
            
            return { 
                singleFormatTime: singleFormatResult.time,
                multiFormatTime: multiFormatResult.time,
                difference: timeDifference,
                percentage: Math.abs(timeDifference / singleFormatResult.time * 100)
            };
        }

        // Function to record clipboard operation data
        function recordClipboardOperation() {
            
            const now = new Date();
            const sizeInMB = lastReadMB;
            const copyTimeMs = lastReadTime;
            const types = lastReadTypes;
            const formatSizes = lastFormatSizes;
            
            // Calculate throughput in MB per second
            const throughput = parseFloat(sizeInMB) / (copyTimeMs / 1000);
            
            const record = {
                datetime: now.toISOString(),
                totalSizeMB: parseFloat(sizeInMB),
                copyTimeMs: copyTimeMs,
                types: types,
                formatSizes: formatSizes,
                sizePerType: parseFloat(sizeInMB) / types.length,
                throughput: throughput,
                highlighted: false // Add highlighted property
            };
            
            clipboardRecords.push(record);
            
            log(`Record added: ${now.toLocaleTimeString()} - Size: ${sizeInMB}MB - Time: ${copyTimeMs.toFixed(2)}ms - Throughput: ${throughput.toFixed(2)} MB/s - Types: ${types.join(', ')}`, "success");
            log(`Total records: ${clipboardRecords.length}`);
            
            updateRecordsTable();
            saveRecordsToLocalStorage(); // Save to localStorage after adding record
            console.log("Clipboard Records:", clipboardRecords);
        }

        // Helper function to format format sizes for display
        function formatSizesDisplay(formatSizes) {
            if (!formatSizes || Object.keys(formatSizes).length === 0) {
                return 'N/A';
            }
            
            return Object.entries(formatSizes)
                .map(([format, size]) => `${format.split('/').pop()}: ${size} MB`)
                .join('<br>');
        }

        // Function to update the records table
        function updateRecordsTable() {
            const tableBody = document.getElementById('records-body');
            tableBody.innerHTML = '';
            
            clipboardRecords.forEach((record, index) => {
                const row = document.createElement('tr');
                
                if (record.highlighted) {
                    row.className = 'highlighted';
                }
                
                const time = new Date(record.datetime);
                const timeFormatted = time.toLocaleTimeString();
                
                // Format the sizes of each format nicely for display
                const formatSizesHtml = formatSizesDisplay(record.formatSizes);
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${timeFormatted}</td>
                    <td>${record.totalSizeMB.toFixed(2)}</td>
                    <td>${record.copyTimeMs.toFixed(2)}</td>
                    <td>${record.throughput ? record.throughput.toFixed(2) : 'N/A'}</td>
                    <td>${record.types.length}</td>
                    <td>${record.sizePerType ? record.sizePerType.toFixed(2) : 'N/A'}</td>
                    <td>${formatSizesHtml}</td>
                    <td>${record.types.join(', ')}</td>
                    <td><input type="checkbox" class="highlight-checkbox" data-index="${index}" ${record.highlighted ? 'checked' : ''}></td>
                    <td>
                        <button class="delete-record" data-index="${index}">Delete</button>
                        <button class="run-again" data-index="${index}">Run again</button>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
            
            // Add event listeners to delete buttons
            document.querySelectorAll('.delete-record').forEach(button => {
                button.addEventListener('click', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    deleteRecord(index);
                });
            });
            
            // Add event listeners to "Run again" buttons
            document.querySelectorAll('.run-again').forEach(button => {
                button.addEventListener('click', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    runRecord(clipboardRecords[index]);
                });
            });
            
            // Add event listeners to highlight checkboxes
            document.querySelectorAll('.highlight-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function(e) {
                    const index = parseInt(this.getAttribute('data-index'));
                    toggleHighlight(index, this.checked);
                });
            });
        }
        
        // Function to toggle highlight state for a record
        function toggleHighlight(index, isHighlighted) {
            if (index >= 0 && index < clipboardRecords.length) {
                clipboardRecords[index].highlighted = isHighlighted;
                
                // Update row appearance
                const tableRows = document.querySelectorAll('#records-body tr');
                if (tableRows[index]) {
                    if (isHighlighted) {
                        tableRows[index].classList.add('highlighted');
                    } else {
                        tableRows[index].classList.remove('highlighted');
                    }
                }
                
                // Save to localStorage
                saveRecordsToLocalStorage();
                
                log(`${isHighlighted ? 'Highlighted' : 'Unhighlighted'} record #${index + 1}`, "info");
            }
        }
        
        // Function to delete a specific record
        function deleteRecord(index) {
            if (index >= 0 && index < clipboardRecords.length) {
                const record = clipboardRecords[index];
                const time = new Date(record.datetime).toLocaleTimeString();
                
                // Remove the record from the array
                clipboardRecords.splice(index, 1);
                
                // Update the table
                updateRecordsTable();
                
                // Save to localStorage
                saveRecordsToLocalStorage();
                
                log(`Deleted record #${index + 1} from ${time}`, "info");
            } else {
                log(`Invalid record index: ${index}`, "error");
            }
        }

        // Function to export records as CSV
        function exportRecordsAsCSV() {
            if (clipboardRecords.length === 0) {
                log("No records to export", "error");
                return;
            }
            
            const headers = ['Timestamp', 'Size (MB)', 'Duration (ms)', 'Throughput (MB/s)', 'NumFormats', 'Size/Type (MB)', 'Format Sizes', 'Formats'];
            
            let csvContent = headers.join(',') + '\n';
            
            clipboardRecords.forEach(record => {
                // Format sizes as base64 encoded string for CSV to avoid parsing issues
                const formatSizesStr = record.formatSizes ? 
                    btoa(JSON.stringify(record.formatSizes)) : 'N/A';
                
                const row = [
                    record.datetime,
                    record.totalSizeMB.toFixed(2),
                    record.copyTimeMs.toFixed(2),
                    record.throughput ? record.throughput.toFixed(2) : 'N/A',
                    record.types.length,
                    record.sizePerType ? record.sizePerType.toFixed(2) : 'N/A',
                    `"${formatSizesStr}"`,
                    '"' + record.types.join('; ') + '"'
                ];
                csvContent += row.join(',') + '\n';
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `clipboard-records-${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            log("Records exported as CSV", "success");
        }

        // Function to import records from CSV
        function importRecordsFromCSV(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    const lines = csvContent.split('\n');
                    
                    // Check if CSV has at least a header and one data row
                    if (lines.length < 2) {
                        log("Invalid CSV: file is empty or has no data rows", "error");
                        return;
                    }
                    
                    // Parse header to identify column positions
                    const headers = lines[0].split(',');
                    const colIndexes = {
                        timestamp: headers.indexOf('Timestamp'),
                        size: headers.indexOf('Size (MB)'),
                        duration: headers.indexOf('Duration (ms)'),
                        throughput: headers.indexOf('Throughput (MB/s)'),
                        numFormats: headers.indexOf('NumFormats'),
                        sizePerType: headers.indexOf('Size/Type (MB)'),
                        formatSizes: headers.indexOf('Format Sizes'),
                        formats: headers.indexOf('Formats')
                    };
                    
                    // Check if required columns are present
                    if (colIndexes.timestamp === -1 || colIndexes.duration === -1 || colIndexes.formats === -1) {
                        log("Invalid CSV: missing required columns (Timestamp, Duration, Formats)", "error");
                        return;
                    }
                    
                    // Process data rows
                    let importedRecords = [];
                    let skippedRows = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue; // Skip empty lines
                        
                        // Handle quoted fields with commas inside
                        const values = [];
                        let inQuote = false;
                        let currentValue = '';
                        
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            
                            if (char === '"' && (j === 0 || line[j-1] !== '\\')) {
                                inQuote = !inQuote;
                            } else if (char === ',' && !inQuote) {
                                values.push(currentValue);
                                currentValue = '';
                            } else {
                                currentValue += char;
                            }
                        }
                        values.push(currentValue); // Add the last value
                        
                        try {
                            // Parse timestamp
                            const timestamp = values[colIndexes.timestamp].replace(/"/g, '');
                            
                            // Parse formats
                            const formatsStr = values[colIndexes.formats].replace(/"/g, '');
                            const types = formatsStr.split(';').map(type => type.trim()).filter(type => type);
                            
                            // Parse format sizes if available
                            let formatSizes = {};
                            if (colIndexes.formatSizes !== -1 && values[colIndexes.formatSizes]) {
                                try {
                                    // Clean up the string and check if it's base64 encoded
                                    const formatSizesStr = values[colIndexes.formatSizes].replace(/"/g, '');
                                    
                                    if (formatSizesStr !== 'N/A') {
                                        try {
                                            // Try to decode as base64 first (newer format)
                                            const decoded = atob(formatSizesStr);
                                            formatSizes = JSON.parse(decoded);
                                        } catch (decodeErr) {
                                            // Fall back to legacy format with semicolons
                                            const legacyStr = formatSizesStr.replace(/;/g, ',');
                                            formatSizes = JSON.parse(legacyStr);
                                        }
                                    }
                                } catch (e) {
                                    log(`Error parsing format sizes for row ${i}: ${e.message}`, "error");
                                    // Continue with empty formatSizes rather than skipping the record
                                    formatSizes = {};
                                }
                            }
                            
                            // Create record object
                            const record = {
                                datetime: timestamp,
                                totalSizeMB: parseFloat(values[colIndexes.size]) || 0,
                                copyTimeMs: parseFloat(values[colIndexes.duration]) || 0,
                                types: types,
                                formatSizes: formatSizes,
                                sizePerType: parseFloat(values[colIndexes.sizePerType]) || 0,
                                throughput: parseFloat(values[colIndexes.throughput]) || 0,
                                highlighted: false
                            };
                            
                            importedRecords.push(record);
                        } catch (e) {
                            skippedRows++;
                            log(`Error parsing row ${i}: ${e.message}`, "error");
                        }
                    }
                    
                    if (importedRecords.length === 0) {
                        log("No valid records found in CSV file", "error");
                        return;
                    }
                    
                    // Add imported records to clipboardRecords
                    clipboardRecords = [...clipboardRecords, ...importedRecords];
                    
                    // Update the table
                    updateRecordsTable();
                    
                    // Save to localStorage
                    saveRecordsToLocalStorage();
                    
                    log(`Successfully imported ${importedRecords.length} records from CSV`, "success");
                    if (skippedRows > 0) {
                        log(`Skipped ${skippedRows} invalid rows during import`, "info");
                    }
                    
                } catch (e) {
                    log(`Error importing CSV: ${e.message}`, "error");
                }
            };
            
            reader.onerror = function() {
                log("Error reading the CSV file", "error");
            };
            
            reader.readAsText(file);
        }

        document.getElementById('export-records').addEventListener('click', () => {
            saveRecordsToLocalStorage(); // Ensure latest records are saved
            exportRecordsAsCSV();
        });
        
        // Add event listener for import CSV button
        document.getElementById('import-records').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });
        
        // Add event listener for file input change
        document.getElementById('csv-file-input').addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                importRecordsFromCSV(this.files[0]);
                // Reset the file input so the same file can be selected again
                this.value = '';
            }
        });

        // Function to save records to localStorage
        function saveRecordsToLocalStorage() {
            localStorage.setItem('clipboardRecords', JSON.stringify(clipboardRecords));
            log("Records saved to localStorage", "info");
        }
        
        // Function to load records from localStorage
        function loadRecordsFromLocalStorage() {
            try {
                const storedRecords = localStorage.getItem('clipboardRecords');
                if (storedRecords) {
                    clipboardRecords = JSON.parse(storedRecords);
                    log(`Loaded ${clipboardRecords.length} records from localStorage`, "success");
                    updateRecordsTable();
                } else {
                    log("No records found in localStorage", "info");
                }
            } catch (e) {
                log(`Error loading records from localStorage: ${e.message}`, "error");
                console.error("Failed to parse stored records:", e);
            }
        }

        // Function to log messages on the HTML page
        function log(message, type = "default", replace = false) {
            const logContainer = document.getElementById('log-container');
            let entry;
            
            if (replace && logContainer.lastChild) {
                entry = logContainer.lastChild;
            } else {
                entry = document.createElement('div');
                entry.className = 'log-entry';
                logContainer.appendChild(entry);
            }
            
            if (type !== "default") {
                entry.className = `log-entry ${type}`;
            }
            
            const timestamp = new Date().toTimeString().substr(0, 8);
            entry.textContent = `[${timestamp}] ${message}`;
            
            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Event listeners
        document.getElementById('write-btn').addEventListener('click', async () => {
            const currentSize = parseInt(document.getElementById('data-size').value) || 50;
            
            // Generate data if it doesn't exist or if the size has changed
            if (!generatedData || currentSize !== lastGeneratedSize) {
                log(`Data size changed from ${lastGeneratedSize}MB to ${currentSize}MB, regenerating data...`);
                lastGeneratedSize = currentSize;
                generatedData = generateDataOfSize(currentSize);
            }
            
            // Save previous write time if exists
            if (lastWriteTime) {
                previousWriteTime = lastWriteTime;
            }
            
            lastWriteTime = await writeDataToClipboard(generatedData);
        });

        document.getElementById('read-btn').addEventListener('click', async () => {
            const result = await readFromClipboard();
            
            if (result) {
                // Save previous read time if exists
                if (lastReadTime) {
                    previousReadTime = lastReadTime;
                }
                
                lastReadTime = result.time;
            }
        });

        document.getElementById('record-btn').addEventListener('click', () => {
            recordClipboardOperation();
        });

        document.getElementById('clear-log').addEventListener('click', () => {
            document.getElementById('log-container').innerHTML = '';
            log("Log cleared");
        });
        
        // Records management button event listeners
        document.getElementById('clear-records').addEventListener('click', () => {
            clipboardRecords = [];
            updateRecordsTable();
            localStorage.removeItem('clipboardRecords'); // Remove from localStorage
            log("Records cleared", "info");
        });
        
        document.getElementById('export-records').addEventListener('click', () => {
            saveRecordsToLocalStorage(); // Ensure latest records are saved
            exportRecordsAsCSV();
        });
        
        // Add event listener for import CSV button
        // document.getElementById('import-records').addEventListener('click', () => {
        //     document.getElementById('csv-file-input').click();
        // });
        
        // Add event listener for file input change
        document.getElementById('csv-file-input').addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                importRecordsFromCSV(this.files[0]);
                // Reset the file input so the same file can be selected again
                this.value = '';
            }
        });

        // Function to run an experiment with specified format sizes
        async function runExperiment(sizesDictionary) {
            // Save original settings to restore later
            const originalSettings = {
                textPlain: document.getElementById('format-text-plain').checked,
                textPlainSize: document.getElementById('format-text-plain-size').value,
                textHtml: document.getElementById('format-text-html').checked,
                textHtmlSize: document.getElementById('format-text-html-size').value,
                custom: document.getElementById('format-custom').checked,
                customCount: document.getElementById('custom-format-count').value,
                customSize: document.getElementById('format-custom-size').value,
                defaultSize: document.getElementById('data-size').value
            };
            
            log("Starting experiment with specified format sizes...", "info");
            
            try {
                // Configure formats based on the dictionary
                document.getElementById('format-text-plain').checked = sizesDictionary.hasOwnProperty('text/plain');
                if (sizesDictionary['text/plain']) {
                    document.getElementById('format-text-plain-size').value = sizesDictionary['text/plain'];
                }
                
                document.getElementById('format-text-html').checked = sizesDictionary.hasOwnProperty('text/html');
                if (sizesDictionary['text/html']) {
                    document.getElementById('format-text-html-size').value = sizesDictionary['text/html'];
                }
                
                const customFormats = Object.keys(sizesDictionary).filter(key => key.startsWith('web custom/'));
                document.getElementById('format-custom').checked = customFormats.length > 0;
                if (customFormats.length > 0) {
                    document.getElementById('custom-format-count').value = customFormats.length;
                    document.getElementById('format-custom-size').value = sizesDictionary[customFormats[0]];
                }
                
                // Find the largest size for data generation
                const maxSize = Math.max(...Object.values(sizesDictionary));
                document.getElementById('data-size').value = maxSize;
                
                // Generate data based on the largest size
                log(`Generating data for experiment (max size: ${maxSize} MB)...`);
                const generatedData = generateDataOfSize(maxSize);
                
                // Write to clipboard
                log("Writing to clipboard with configured formats...");
                const writeTime = await writeDataToClipboard(generatedData);
                
                if (writeTime) {
                    // Wait a moment before reading
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Read from clipboard
                    log("Reading from clipboard...");
                    const readResult = await readFromClipboard();
                    
                    if (readResult) {
                        // Record the operation
                        log("Recording experiment results...");
                        recordClipboardOperation();
                    }
                }
            } catch (error) {
                log(`Error during experiment: ${error.message}`, "error");
            } finally {
                // Restore original settings
                document.getElementById('format-text-plain').checked = originalSettings.textPlain;
                document.getElementById('format-text-plain-size').value = originalSettings.textPlainSize;
                document.getElementById('format-text-html').checked = originalSettings.textHtml;
                document.getElementById('format-text-html-size').value = originalSettings.textHtmlSize;
                document.getElementById('format-custom').checked = originalSettings.custom;
                document.getElementById('custom-format-count').value = originalSettings.customCount;
                document.getElementById('format-custom-size').value = originalSettings.customSize;
                document.getElementById('data-size').value = originalSettings.defaultSize;
                
                log("Experiment completed and original settings restored", "success");
            }
        }

        document.getElementById('run-experiment-btn').addEventListener('click', () => {
            // Get sizes dictionary from UI values
            const sizesDictionary = {};
            
            // Add text/plain format if selected
            if (document.getElementById('format-text-plain').checked) {
                const size = parseInt(document.getElementById('format-text-plain-size').value) || 50;
                sizesDictionary['text/plain'] = size;
            }
            
            // Add text/html format if selected
            if (document.getElementById('format-text-html').checked) {
                const size = parseInt(document.getElementById('format-text-html-size').value) || 50;
                sizesDictionary['text/html'] = size;
            }
            
            // Add custom formats if selected
            if (document.getElementById('format-custom').checked) {
                const count = parseInt(document.getElementById('custom-format-count').value) || 1;
                const size = parseInt(document.getElementById('format-custom-size').value) || 50;
                
                for (let i = 1; i <= count; i++) {
                    sizesDictionary[`web custom/format-${i}`] = size;
                }
            }
            
            // Log the configuration
            log(`Experiment configuration: ${JSON.stringify(sizesDictionary)}`, "info");
            
            runExperiment(sizesDictionary);
        });

        // Function to run an experiment based on a previous record
        function runRecord(record) {
            if (!record || !record.formatSizes) {
                log("Cannot run experiment: record or format sizes not available", "error");
                return;
            }
            
            log(`Running experiment based on record from ${new Date(record.datetime).toLocaleTimeString()}...`, "info");
            
            // Convert record's formatSizes to a sizesDictionary for runExperiment
            const sizesDictionary = {};
            
            // Process each format and its size from the record
            Object.entries(record.formatSizes).forEach(([format, size]) => {
                sizesDictionary[format] = size;
            });
            
            // Check if we have any valid formats
            if (Object.keys(sizesDictionary).length === 0) {
                log("No valid formats found in the record", "error");
                return;
            }
            
            // Update UI elements to match the record's format sizes
            document.getElementById('format-text-plain').checked = sizesDictionary.hasOwnProperty('text/plain');
            if (sizesDictionary['text/plain']) {
                document.getElementById('format-text-plain-size').value = sizesDictionary['text/plain'];
            }
            
            document.getElementById('format-text-html').checked = sizesDictionary.hasOwnProperty('text/html');
            if (sizesDictionary['text/html']) {
                document.getElementById('format-text-html-size').value = sizesDictionary['text/html'];
            }
            
            const customFormats = Object.keys(sizesDictionary).filter(key => key.startsWith('web custom/'));
            document.getElementById('format-custom').checked = customFormats.length > 0;
            if (customFormats.length > 0) {
                document.getElementById('custom-format-count').value = customFormats.length;
                document.getElementById('format-custom-size').value = sizesDictionary[customFormats[0]];
            }
            
            // Find the largest size for data size field
            const maxSize = Math.max(...Object.values(sizesDictionary));
            document.getElementById('data-size').value = maxSize;
            
            log(`Recreating experiment with formats: ${Object.keys(sizesDictionary).join(', ')}`, "info");
            log(`UI updated with sizes: ${JSON.stringify(sizesDictionary)}`, "info");
            
            // Run the experiment with the extracted sizes
            runExperiment(sizesDictionary);
        }
        
        // Function to run experiments for all records (creating new records)
        async function rerunAllExperiments() {
            if (clipboardRecords.length === 0) {
                log("No records to rerun", "error");
                return;
            }
            
            log(`Starting to re-run experiments for all ${clipboardRecords.length} records...`, "info");
            
            // Disable the button while running
            const rerunAllNewBtn = document.getElementById('rerun-all-new-btn');
            rerunAllNewBtn.disabled = true;
            rerunAllNewBtn.textContent = "Running...";

            const tmpRecords = [...clipboardRecords]; // Create a copy of the records to avoid modifying the original array
            
            try {
                // Process each record in sequence
                for (let i = 0; i < tmpRecords.length; i++) {
                    const record = tmpRecords[i];
                    log(`Re-running experiment ${i+1} of ${tmpRecords.length}...`, "info");
                    
                    // Convert record's formatSizes to a sizesDictionary for runExperiment
                    const sizesDictionary = {};
                    
                    // Process each format and its size from the record
                    Object.entries(record.formatSizes).forEach(([format, size]) => {
                        sizesDictionary[format] = size;
                    });
                    
                    if (Object.keys(sizesDictionary).length === 0) {
                        log(`Skipping record ${i+1}: no valid formats found`, "error");
                        continue;
                    }
                    
                    // Run the experiment with the extracted sizes - this will create a new record
                    await runExperiment(sizesDictionary);
                    
                    // Add a small delay between experiments
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                log(`Completed re-running experiments for all ${tmpRecords.length} records`, "success");
            } catch (error) {
                log(`Error during re-run all experiments: ${error.message}`, "error");
            } finally {
                // Re-enable the button
                rerunAllNewBtn.disabled = false;
                rerunAllNewBtn.textContent = "Re-run all (new)";
            }
        }

        // Initial log message
        log("Clipboard Performance Test initialized");
        log("Steps: 1) Set data size and formats, 2) Write to clipboard, 3) Read and record results");

        // Load records from localStorage
        loadRecordsFromLocalStorage();

        // Check if running in secure context (required for clipboard API)
        if (!window.isSecureContext) {
            log("Warning: This page is not running in a secure context. Clipboard API may be limited.", "error");
        }

        // Load records from localStorage on page load
        loadRecordsFromLocalStorage();

        // Save records to localStorage before page unload
        window.addEventListener('beforeunload', saveRecordsToLocalStorage);

        // Add event listener for "Rerun All" button
        document.getElementById('rerun-all-btn').addEventListener('click', () => {
            rerunAllRecords();
        });
        
        // Add event listener for "Re-run all (new)" button
        document.getElementById('rerun-all-new-btn').addEventListener('click', () => {
            rerunAllExperiments();
        });

        document.getElementById('import-records').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });
    </script>
</body>
</html>